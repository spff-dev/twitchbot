// /srv/bots/twitchbot/bot.js
require('dotenv').config();
const fs = require('fs');
const path = require('path');
const tmi = require('tmi.js');
const { startEventSubBot, startEventSubBroadcaster } = require('./lib/eventsub');
const buildHandlers = require('./events/handlers');

// ---- Env ----
const {
  BOT_USERNAME,
  CHANNELS,
  TWITCH_CLIENT_ID,
  TWITCH_CLIENT_SECRET,
  TWITCH_REFRESH_TOKEN,
  BROADCASTER_REFRESH_TOKEN, // needed for subs/bits/ad EventSub + schedule polling
  CMD_PREFIX = '!'
} = process.env;

if (!BOT_USERNAME || !CHANNELS || !TWITCH_CLIENT_ID || !TWITCH_CLIENT_SECRET || !TWITCH_REFRESH_TOKEN) {
  console.error("Missing required env vars. Need BOT_USERNAME, CHANNELS, TWITCH_CLIENT_ID, TWITCH_CLIENT_SECRET, TWITCH_REFRESH_TOKEN.");
  process.exit(1);
}
if (!BROADCASTER_REFRESH_TOKEN) {
  console.warn("[WARN] BROADCASTER_REFRESH_TOKEN is not set; subs/bits/ad EventSub and schedule warnings will fail. You can add it later.");
}

// ---- Auth: bot access token (user token) auto-refresh ----
let tokenState = { accessToken: null, expiresAt: 0, refreshTimer: null };

async function refreshAccessToken(reason = "scheduled") {
  const params = new URLSearchParams({
    client_id: TWITCH_CLIENT_ID,
    client_secret: TWITCH_CLIENT_SECRET,
    grant_type: 'refresh_token',
    refresh_token: TWITCH_REFRESH_TOKEN
  });

  const res = await fetch('https://id.twitch.tv/oauth2/token', {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: params.toString()
  });

  if (!res.ok) {
    const text = await res.text();
    throw new Error(`Token refresh failed (${reason}): ${res.status} ${text}`);
  }

  const data = await res.json();

  if (data.refresh_token && data.refresh_token !== TWITCH_REFRESH_TOKEN) {
    console.warn("[AUTH] Twitch rotated your refresh_token. Update your .env to keep future restarts healthy.");
    console.warn("[AUTH] New refresh_token:", data.refresh_token);
  }

  const now = Date.now();
  const expiresInMs = (data.expires_in || 3600) * 1000;
  tokenState.accessToken = data.access_token;
  tokenState.expiresAt = now + expiresInMs;

  const skew = Math.min(5 * 60 * 1000, Math.floor(expiresInMs * 0.1)); // 5m or 10%
  const refreshIn = Math.max(60 * 1000, expiresInMs - skew);
  if (tokenState.refreshTimer) clearTimeout(tokenState.refreshTimer);
  tokenState.refreshTimer = setTimeout(() => {
    refreshAccessToken("timer").catch(err => console.error("[AUTH] scheduled refresh error:", err));
  }, refreshIn);

  console.log(`[AUTH] ${reason} refresh ok. Next refresh in ~${Math.round(refreshIn/1000)}s, expires_in=${Math.round(expiresInMs/1000)}s`);
  return tokenState.accessToken;
}
function tokenWillExpireSoon() { return Date.now() > (tokenState.expiresAt - 60 * 1000); }

// ---- Auth: broadcaster access token (mint on demand from refresh) ----
let bState = { accessToken: null, expiresAt: 0 };
async function getBroadcasterAccessToken() {
  if (!BROADCASTER_REFRESH_TOKEN) throw new Error('Missing BROADCASTER_REFRESH_TOKEN in .env');
  const now = Date.now();
  if (bState.accessToken && now < (bState.expiresAt - 60 * 1000)) return bState.accessToken;

  const params = new URLSearchParams({
    client_id: TWITCH_CLIENT_ID,
    client_secret: TWITCH_CLIENT_SECRET,
    grant_type: 'refresh_token',
    refresh_token: BROADCASTER_REFRESH_TOKEN
  });
  const res = await fetch('https://id.twitch.tv/oauth2/token', {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: params.toString()
  });
  if (!res.ok) {
    const text = await res.text();
    throw new Error(`Broadcaster token refresh failed: ${res.status} ${text}`);
  }
  const data = await res.json();
  bState.accessToken = data.access_token;
  bState.expiresAt = now + ((data.expires_in || 3600) * 1000);
  return bState.accessToken;
}

// ---- Config (JSONC) + Commands with overrides ----
const CMD_DIR = path.join(__dirname, 'commands');
const CONFIG_PATH = path.join(__dirname, 'config', 'commands.json');

function readJsonC(file) {
  let raw = fs.readFileSync(file, 'utf8');
  raw = raw.replace(/\/\*[\s\S]*?\*\//g, '');      // /* block comments */
  raw = raw.replace(/(^|\s)\/\/.*$/gm, '');        // // line comments
  raw = raw.replace(/,(\s*[}\]])/g, '$1');         // trailing commas
  return JSON.parse(raw);
}

function loadOverrides() {
  try {
    const json = readJsonC(CONFIG_PATH);
    const table = {};
    const src = (json && json.commands) || {};
    for (const [k, v] of Object.entries(src)) table[String(k).toLowerCase()] = v || {};
    return table;
  } catch (e) {
    if (e.code !== 'ENOENT') console.warn(`[CFG] Failed to read ${CONFIG_PATH}: ${e.message}`);
    return {};
  }
}

// Greeting config (hot-reloaded with !reload)
const DEFAULT_GREETING = {
  enabled: true,
  message: "SpiffyOS online âœ… - type !help for commands.",
  delayMs: 1500,
  minIntervalSec: 900
};
let greetCfg = { ...DEFAULT_GREETING };
function loadGreeting() {
  try {
    const json = readJsonC(CONFIG_PATH);
    greetCfg = { ...DEFAULT_GREETING, ...(json.greeting || {}) };
  } catch {
    greetCfg = { ...DEFAULT_GREETING };
  }
}

function applyOverride(mod, ov) {
  if (!ov) return mod;
  const out = { ...mod };
  if (typeof ov.enabled === 'boolean' && ov.enabled === false) out.__disabled = true;
  if (ov.description != null) out.description = String(ov.description);
  if (ov.permission != null) out.permission = String(ov.permission).toLowerCase();
  if (ov.cooldownSec != null) out.cooldownSec = Number(ov.cooldownSec) || 0;
  if (Array.isArray(ov.aliases)) out.aliases = ov.aliases.map(a => String(a));
  return out;
}

function loadCommands(dir, overrides) {
  const commands = new Map();
  const triggers = new Map(); // trigger -> command.name
  if (!fs.existsSync(dir)) {
    console.warn(`[CMD] Directory missing: ${dir}`);
    return { commands, triggers };
  }
  const files = fs.readdirSync(dir).filter(f => f.endsWith('.js'));
  for (const f of files) {
    try {
      const mod0 = require(path.join(dir, f));
      if (!mod0 || !mod0.name || !mod0.run) { console.warn(`[CMD] Skipping ${f}: missing name/run`); continue; }
      const ov = overrides[mod0.name.toLowerCase()] || null;
      const mod = applyOverride(mod0, ov);
      if (mod.__disabled) { console.log(`[CMD] Disabled by config: ${mod.name}`); continue; }
      const perm = (mod.permission || 'everyone').toLowerCase();
      if (!['everyone','mod','broadcaster'].includes(perm)) {
        console.warn(`[CMD] ${mod.name}: invalid permission "${mod.permission}", defaulting to 'everyone'`);
        mod.permission = 'everyone';
      }
      const aliasList = [mod.name, ...(mod.aliases || [])].map(s => s.toLowerCase());
      commands.set(mod.name.toLowerCase(), mod);
      for (const a of aliasList) triggers.set(a, mod.name.toLowerCase());
    } catch (e) {
      console.warn(`[CMD] Failed to load ${f}: ${e.message}`);
    }
  }
  console.log(`[CMD] Loaded ${commands.size} commands from ${dir}`);
  return { commands, triggers };
}

// Hot-reload helpers used by !reload
let commands = new Map();
let triggers = new Map();
function clearCommandCache() {
  for (const k of Object.keys(require.cache)) if (k.startsWith(CMD_DIR)) delete require.cache[k];
}
function rebuildCommands() {
  clearCommandCache();
  const overrides = loadOverrides();
  loadGreeting();
  const loaded = loadCommands(CMD_DIR, overrides);
  commands = loaded.commands;
  triggers = loaded.triggers;
  console.log(`[CFG] Overrides applied from ${CONFIG_PATH}`);
  return { count: commands.size };
}

// ---- Greeting runtime (per-channel guard) ----
const lastGreetAt = new Map();   // channel -> epoch ms
const pendingGreet = new Set();  // channels mid-delay

function maybeGreet(client, channel, reason = 'join') {
  if (!greetCfg.enabled) return;
  const key = channel.toLowerCase();
  const now = Date.now();
  const minGap = (greetCfg.minIntervalSec || 0) * 1000;
  const last = lastGreetAt.get(key) || 0;
  if (now - last < minGap) return;
  if (pendingGreet.has(key)) return;

  pendingGreet.add(key);
  const delay = Math.max(0, Number(greetCfg.delayMs) || 0);
  setTimeout(async () => {
    try {
      await client.say(channel, String(greetCfg.message || DEFAULT_GREETING.message));
      lastGreetAt.set(key, Date.now());
    } finally {
      pendingGreet.delete(key);
    }
  }, delay);
}

// ---- Main bot ----
let eventSubBotStarted = false;
let eventSubBcStarted  = false;

async function main() {
  await refreshAccessToken("startup");
  const channels = CHANNELS.split(',').map(c => c.trim().toLowerCase()).filter(Boolean);

  const client = new tmi.Client({
    options: { debug: false },
    connection: { secure: true, reconnect: true },
    identity: { username: BOT_USERNAME, password: `oauth:${tokenState.accessToken}` },
    channels
  });

  // Patch refresh so future tokens update in-memory password for reconnects
  const originalRefresh = refreshAccessToken;
  refreshAccessToken = async (reason) => {
    const tok = await originalRefresh.call(null, reason);
    client.opts.identity.password = `oauth:${tok}`;
    console.log('[AUTH] Updated in-memory password with fresh token.');
    return tok;
  };

  client.on('connected', (addr, port) => {
    console.log(`Connected to ${addr}:${port} as ${BOT_USERNAME}, joined ${channels.join(', ')}`);
    for (const c of channels) maybeGreet(client, `#${c}`, 'connected');

    const broadcasterLogin = (channels[0] || '').replace(/^#/, '').toLowerCase();
    const handlers = buildHandlers({ tmiClient: client, channel: `#${broadcasterLogin}` });

    // BOT session: follows v2 (uses bot token)
    if (!eventSubBotStarted) {
      eventSubBotStarted = true;
      startEventSubBot({
        clientId: TWITCH_CLIENT_ID,
        getBotToken: () => tokenState.accessToken,
        broadcasterLogin,
        ...handlers
      }).catch(err => {
        console.error('[EVT/BOT] failed to start', err);
        eventSubBotStarted = false;
      });
    }

    // Broadcaster session: bits + subs + ad begin (uses broadcaster token)
    if (!eventSubBcStarted) {
      eventSubBcStarted = true;
      startEventSubBroadcaster({
        clientId: TWITCH_CLIENT_ID,
        getBroadcasterToken: () => getBroadcasterAccessToken(),
        getBotToken: () => tokenState.accessToken, // announcements use bot token
        broadcasterLogin,
        ...handlers
      }).catch(err => {
        console.error('[EVT/BC] failed to start', err);
        eventSubBcStarted = false;
      });
    }
  });

  client.on('disconnected', async (reason) => {
    console.warn('[NET] Disconnected:', reason);
    if (tokenWillExpireSoon()) {
      try {
        await refreshAccessToken("pre-reconnect");
        client.opts.identity.password = `oauth:${tokenState.accessToken}`;
        console.log('[AUTH] Updated password before reconnect.');
      } catch (err) {
        console.error('[AUTH] pre-reconnect refresh failed:', err);
      }
    }
  });

  client.on('join', (channel, username) => {
    if ((username || '').toLowerCase() === BOT_USERNAME.toLowerCase()) {
      maybeGreet(client, channel, 'join');
    }
  });

  // Initial command + overrides load
  rebuildCommands();

  client.on('message', async (channel, tags, message, self) => {
    if (self) return;
    if (!message || message[0] !== CMD_PREFIX) return;

    const user = (tags['display-name'] || tags.username || '').toString();
    const userId = tags['user-id'] || user.toLowerCase();

    const raw = message.slice(CMD_PREFIX.length).trim();
    if (!raw) return;
    const [cmdTrigger, ...args] = raw.split(/\s+/);
    const key = triggers.get(cmdTrigger.toLowerCase());
    if (!key) return;

    const cmd = commands.get(key);

    function isBroadcaster(t) { const b = t.badges || {}; return typeof b === 'object' && b.broadcaster === '1'; }
    function isMod(t) { return !!t.mod || isBroadcaster(t); }
    function hasPermission(perm, t) {
      if (perm === 'everyone') return true;
      if (perm === 'mod') return isMod(t);
      if (perm === 'broadcaster') return isBroadcaster(t);
      return false;
    }

    if (!hasPermission((cmd.permission || 'everyone').toLowerCase(), tags)) return;

    // cooldowns: Map<command, Map<userId, lastMs>>
    if (!global.__cooldowns) global.__cooldowns = new Map();
    const cooldowns = global.__cooldowns;
    function checkCooldown(name, uid, sec) {
      if (!sec) return { ok: true };
      const bucket = cooldowns.get(name) || new Map();
      const now = Date.now();
      const last = bucket.get(uid) || 0;
      const delta = (now - last) / 1000;
      if (delta < sec) return { ok: false, wait: Math.ceil(sec - delta) };
      bucket.set(uid, now);
      cooldowns.set(name, bucket);
      return { ok: true };
    }

    const cd = checkCooldown(cmd.name.toLowerCase(), userId, cmd.cooldownSec || 0);
    if (!cd.ok) return;

    const say = (text) => client.say(channel, text);
    const reply = (text) => client.say(channel, `@${user} ${text}`);

    // Threaded reply helper via Helix, fallback to @mention if it fails
    const replyThread = async (text) => {
      const parentId = tags['id'];
      const login = channel.replace(/^#/, '').toLowerCase();
      try {
        // sender_id (bot)
        const meRes = await fetch('https://api.twitch.tv/helix/users', {
          headers: { Authorization: `Bearer ${tokenState.accessToken}`, 'Client-Id': TWITCH_CLIENT_ID }
        });
        const me = await meRes.json();
        const sender_id = me?.data?.[0]?.id;

        // broadcaster_id
        const uRes = await fetch(`https://api.twitch.tv/helix/users?login=${encodeURIComponent(login)}`, {
          headers: { Authorization: `Bearer ${tokenState.accessToken}`, 'Client-Id': TWITCH_CLIENT_ID }
        });
        const u = await uRes.json();
        const broadcaster_id = u?.data?.[0]?.id;

        const res = await fetch('https://api.twitch.tv/helix/chat/messages', {
          method: 'POST',
          headers: {
            Authorization: `Bearer ${tokenState.accessToken}`,
            'Client-Id': TWITCH_CLIENT_ID,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            broadcaster_id, sender_id,
            message: text,
            reply_parent_message_id: parentId
          })
        });
        if (res.status !== 200) throw new Error(`send reply status ${res.status}`);
      } catch {
        await reply(text);
      }
    };

    try {
      await cmd.run({
        client, channel, tags, user, args,
        say, reply, replyThread,
        prefix: CMD_PREFIX,
        reload: rebuildCommands,
        getToken: () => tokenState.accessToken
      });
    } catch (err) {
      console.error(`[CMD] ${cmd.name} error:`, err);
    }
  });

  try { await client.connect(); }
  catch (err) { console.error('Connect error:', err); process.exit(1); }
}

main().catch(err => { console.error(err); process.exit(1); });
